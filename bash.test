#! /bin/bash

ctrl_k=$'\e[K'
ctrl_l=$'\e[2J'

#functions for cursor operations.
#
function mvCursor()
{
#Descriptions:
#   move cursor.
#Parameters:
#   $1, the direction of moving.
#       `l' move left,   mapping to \033[D
#       `r' move righ,   mapping to \033[C
#       `u' move up,     mapping to \033[A
#       `d' move down,   mapping to \033[B
#       `g' goto column, mapping to \033[G
#       `j' jump to x;y, mapping to \033[H
#   $2, count of repeats for line
#   $3, the value of `y' for jump to ``x;y"
#
#
    local _direction=`echo $1 | tr ludgjr DABGHC`
    echo -ne "\033[${2:-1}${3:+;$3}${_direction}"
    return $?
}
#
function hideCursor()
{
    echo -ne $'\e[?25l'
    return $?
}
#
function showCursor()
{
    echo -ne $'\e[?25h'
    return $?
}
#
function saveCursor()
{
    echo -ne $'\e[s'
    return $?
}
#
function restoreCursor()
{
    echo -ne $'\e[u'      #cannot work???
    return $?
}
#============================================================================

#functions for functional message displaying
#
shopt -s expand_aliases
#
alias showNor='showMsg N'
alias showHi='showMsg H'
alias showWarn='showMsg W'
alias showErr='showMsg E'
alias showOk='showMsg S'
alias showFail='showMsg F'
#
function showMsg()
{
#Descriptions:
#   display functional messages such as Warning,Error,Fail...
#   implement by useing ``echo -ne"
#   caller should handle the format issues.
#   insert `\r' `\n' etc. in the message to control the format
#Parameters:
#   $1, message type
#       `N'     normal message
#       `H'     highlight message
#       `W'     warning message
#       `E'     error message
#       `F'     failure message
#       `S'     success message
#   $2, message content
#   
    local _msgType=$1
    local _colrN=$'\e[0m'
    local _color
#
    case $_msgType in
    H|h) _color=$'\e[1;36m' ;;
    W|w) _color=$'\e[1;33m' ;;
    E|e) _color=$'\e[1;31m' ;;
    S|s) _color=$'\e[7;32m' ;;
    F|f) _color=$'\e[7;31m' ;;
    *)   _color=$'\e[0m' ;;
    esac
#
    echo -ne "$_color$2$_colrN"
    return $?
}
#============================================================================

#definitions
#token
#    A sequence of characters considered a single unit by the shell. It
#    is either a word or an operator.
#metacharacter
#    A character that, when unquoted, separates words. A metacharacter
#    is a space, tab, newline, or one of the following characters: 
#    `|', `&', `;', `(', `)', `<', or `>'.
#word
#    A sequence of characters treated as a unit by the shell. Words may
#    not include unquoted metacharacters.
#name
#    A word consisting solely of letters, numbers, and underscores, and
#    beginning with a letter or underscore. Names are used as shell
#    variable and function names. Also referred to as an identifier.
#operator
#    A control operator or a redirection operator. See Redirections, for
#    a list of redirection operators. Operators contain at least one
#    unquoted metacharacter.
#control operator
#    A token that performs a control function. It is a newline or one of
#    the following: `||', `&&', `&', `;', `;;', `;&', `;;&', `|', `|&',
#    `(', or `)'.
#field
#    A unit of text that is the result of one of the shell expansions.
#    After expansion, when executing a command, the resulting fields are
#    used as the command name and arguments.
#Simple Commands
#    A simple command is the kind of command encountered most often. 
#    It's just a sequence of words separated by blanks, 
#    terminated by one of the shell's control operators. 
#    The first word generally specifies a command to be executed, 
#    with the rest of the words being that command's arguments.
#    The return status  of a simple command is its exit status as provided by 
#    the POSIX 1003.1 waitpid function, 
#    or 128+n if the command was terminated by signal n.
#Lists of Commands
#    A list is a sequence of one or more pipelines separated by one of the
#    operators `;', `&', `&&', or `||', 
#    and optionally terminated by one of `;',`&', or a newline.
#    Of these list operators, `&&' and `||' have equal precedence, 
#    followed by `;' and `&', which have equal precedence.
#============================================================================

#shell operation
#   The following is a brief description of the shell's operation when it 
#   reads and executes a command. Basically, the shell does the following:
#
#    1. Reads its input from a file, from a string supplied as an argument to 
#       the -c invocation option, or from the user's terminal.
#    2. Breaks the input into words and operators, obeying the quoting rules.
#       These tokens are separated by metacharacters.
#       Alias expansion is performed by this step.
#    3. Parses the tokens into simple and compound commands.
#    4. Performs the various shell expansions, breaking the expanded tokens 
#       into lists of filenames and commands and arguments.
#    5. Performs any necessary redirections and removes the 
#       redirection operators and their operands from the argument list.
#    6. Executes the command.
#    7. Optionally waits for the command to complete and 
#       collects its exit status.
#============================================================================

#quoting
#escape character
#    a non-quoted backslash `\' is the Bash escape character.
#    It preserves the literal value of the next character than follows, with
#    the exception of newline.
#    If a \newline pair appears, and the backslash iterslef is not quoted,
#    the \newline is treated as a line conitnuation.
#signal quotes
#    ignore all special meanings.
#double quotes
#    Enclosing characters in double quotes (`"') preserves the 
#    literal value of all characters within the quotes, with the exception of 
#    `$', ``', `\', `!'(when history expansion is enabled).
#    When the shell is in POSIX mode, the `!' 
#    has no special meaning within double quotes, even when 
#    history expansion is enabled. 
#    The character `$' and ``' retain their special meaning within double quotes.
#    The backslash '\' retains its special meaning only when 
#    followed by one of the following characters: `$', ``', `"', `\', or newline. 
#    Within double quotes, backslashes that 
#    are followed by one of these characters are removed.
#    Backslashes preceding characters 
#    without a special meaning are left unmodified. 
#    A double quote may be quoted within double quotes by 
#    preceding it with a backslash. 
#    If enabled, history expansion will be performed unless
#    an `!' appearing in double quotes is escaped using a backslash. 
#    The backslash preceding the `!' is not removed.
#ANSI-C quoting
#    $'string' ...
#locale-specific translation
#    $"string" ...
#============================================================================

#shell expansions
#Expansion is performed on the command line after it has been split into tokens. 
#There are seven kinds of expansion performed:
# * brace expansion
# * tilde expansion
# * parameter and variable expansion
# * arithmetic expansion
# * command substitution
# * word splitting
# * filename expansion
# * quote removal (after all expansions)
#
#Only brace expansion, word splitting, and filename expansion can 
#change the number of words of the expansion; 
#other expansions expand a single word to a single word. 
#The only exceptions to this are the expansions of "$@"  and "${name[@]}".
#
#brace expansion ...
#tilde expansion ...
#parameter expansion 
#    ${parameter:-word} ...
#    ${parameter:+word} ...
#    ${parameter:=word} ...
#    ${parameter:?word} ...
#    ${parameter:offset} ...
#    ${parameter:offset:length} ...
#    ${#parameter} ...
#    ${parameter#word} ...
#    ${parameter##word} ...
#    ${parameter%word} ...
#    ${parameter%%word} ...
#    ${parameter/pattern/string} ...
#    ${parameter//pattern/string} ...
#    ${parameter^pattern} ...
#    ${parameter^^pattern}  ...
#    ${parameter,pattern} ...
#    ${parameter,,pattern}  ...
#    ${@:offset:length} ...
#    ${arry[@]:offset:length} ...
#    ${!prefix*} ...
#    ${!name[*]} ...
#    ...
#arithmetic expansion 
#    $(( expression )) ...
#command substitution
#    $(command) ...
#    `command` ...
#word splitting
#    The shell scans the results of parameter expansion, 
#    command substitution, and arithmetic expansion that 
#    did not occur within double quotes for word splitting.
#    Note that if no expansion occurs, no splitting is performed.
#filename expansion ...
#quote removal ...
#============================================================================

#assignment
#name=[value]
#All values undergo tilde expansion, parameter and variable expansion, 
#command substitution, arithmetic expansion, and quote removal. 
#Word splitting is not performed, with the exception of "$@". 
#Filename expansion is not performed. 
#============================================================================

#redirection
#[n]<word redirecting input
#[n]>word redirecting output
#[n]>&digit- copy digital descriptor to n and close digital descriptor
#[n]<&digit- copy digital descriptor to n and close digital descriptor
#============================================================================

#here document
#[n]<<[-]word
#       here-document
#delimiter
#here string
#[n]<<< word
#============================================================================

#function
#function hi()
#{
#echo $#,$0,$1
#echo ${FUNCNAME[*]}
#return 0   #return -1  `-1' will be regard as an option of cmd `return'
#}
#echo $#,$0,$1
#hi a b
#============================================================================

#declare
#declare variables and/or give them attributes. 
#usages:
#   1)declare [-aAfFgilrtux] 
#   2)declare -p [variable ...]
#   3)declare [-+aAfFgilrtux] [name[=value] ...]
#usage_1, list definitions(variables or funcitons) which matched the attrs
#         if no arguments represents, all definitions will be listed.
#usage_2, display the attributes of each variable
#usage_3, set/unset attributes for each name(variables or functions)
#options:
#   -p      will dispaly the attributes and values of each name
#   -a      array
#   -A      associative array
#   -f      function
#   -F      function name only
#   -i      integer
#   -l      to lower-case, once assigned a value, set all to lower-case
#   -u      to upper-case
#   -r      readonly, cannot be unset or assigned
#   -x      export to subsequent commands
#   -g      global?
#   -t      set trace attribute. (DEBUG/RETURN/... traps) 
#declare -a      #list all array
#declare -A      #list all associative array
#declare -F      #list all functions, only attribute and name displayed.
#declare -f fun_1 fun_2      #add `function' attribute to fun_1 and fun_2
#i=1; j=2; declare -p i j    #display the attributes of variable: i and j
#declare -ir +x va=3 #set va to `integer'&`readonly' and remove `export' attr
#============================================================================

#select
#select name in QUIT *; do 
#	echo "you select ($REPLY)"
#	if [ $REPLY -eq 1 ]; then
#		echo bye bye
#		break
#	fi
#	echo $_colrH"ls $name"$_colrN
#	ls $name
#done
#============================================================================

#read
#read x y <<< 1\ 2
#echo '$x='$x,'$y='$y
#read -n1 x             #only accept one character
#read -s x              #security
#read -p "Enter.." x    #prompt
#read -t 5 x            #time limit
#
##cannot read data from pipe with read??
#cat aFile | while read x
#do
#y+="$x"
#done
#echo $y                #`y' is empty because PIPE use different process...
##we can use:
#while read x
#do
#y+="$x"
#done < aFile           #redirect the standard input. 
#echo "$y"              #keep the read in the main process
#============================================================================

#set
#set a b c d e && echo "$# $*"  #set arguments ($0,$1,...)
#set -- && echo "$#"            #unset positional arguments
#set -x                         #open debug
#set +x                         #close debug
#============================================================================

#case
#cat <<< "'q' to quit"
#while read i
#do
#	case $i in
#	*) echo "you have input $_colrH'$i'$_colrN, go on" ;;&	# use ;;&
#	a) echo 'here is a, stop' ;;								# use ;;
#	b) echo 'here is b, have a rest and go on' ;&				# use ;&
#	c) echo 'here is c, stop' ;;
#	d) echo 'here is d, stop' ;;
#	q) echo 'here is q, bye.bye' ; break ;;
#	esac
#done
#============================================================================

#checking if any branch hasn't pushed to remote
#
#_branches=`git branch | sed 's/\** *//g'`
#
#_errlog="err.log"
#_done='\033[0;40;32m[done]\033[0m'
#_fail='\033[0;40;31m[fail]\033[0m'
#
#for i in $_branches; do
#	cmd="git diff $i origin/$i"
# 	{ 	
#		rm -f $i.diff 
#		$cmd > $i.diff &&
#		echo -e "$_done $i" || ( 
#		echo -e "$_fail $i --> $_errlog" && echo -e "* $cmd" >&2 )
#		} 2>>$_errlog
#done
#
#for i in $_branches; do
#	if [[ -s $i.diff ]] ; then
#		if [[ _first -eq 0 ]] ; then
#			_first=1 && echo -e "\nFollowing branches has not pushed to remote"
#		fi
#		echo "* $i"
#	fi
#done
#============================================================================

#test, -v varname returns TRUE if varname is set
#set tmp
#unset tmp
#[[ -v tmp ]] && echo 'variable ``tmp" is set'
#[[ $tmp == "" ]] && echo 'variable ``tmp" is empty'		# not safe
#tmp="hi, i have been set a value"
#echo ${tmp:?"tmp is unset or null"}
#============================================================================

#history
#history components include 3 portions:
#1) EVENT, expand to a history item
#2) WORD, selects some words from the history item
#3) MODIFIER, manipulate on the words
#about EVENT,
#!!                  expand to last command
#!n                  expand to the `nth' command
#!-n                 expand to the last_minus_n command
#!string             expand to the last command preceding with the `string'
#!?string?           expand to the last command including the `string'
#^string1^string2^   substitute the last command
#!#                  i don't known
#
#about WORD,
#:n                  select the `nth' word (start with 0)
#:^                  select the first argument
#:$                  select the last argument
#:%                  the word matched by the most recent `?string?' search
#:x-y                select the from `xth' to `yth'
#:*                  :1-$
#:x*                 :x-$
#:x-                 i am not sure...
#
#about MODIFIER,
#:h                  HEAD, when there is filename with path, 
#                    remove the filename and the contents following it
#:t                  TAIL, ..., remove the contents above the filename
#:r                  REGULAR, ...
#:e                  EXTENSION, ...
#:p                  PRINT, ...
#:...                can `man history'
#
#ls -al bash.test    # once executed, system saves this CMD to history
#!!:0                # execute ``ls"
#!!:^                # execute ``-al"
#!!:$                # execute ``bash.test"
#!!:1-$              # execute ``-al bash.test"
#!!:0*               # execute ``ls -al bash.test"
#!!:0:p              # print `ls'
#!!:$:p              # print `bash.test'
#!!:^*:p             # print `-al bash.test'
#============================================================================

#tree
#usage: tree [-adfghilnpqrstuvxACDFNS] [-H baseHREF] [-T title ] 
#   [-L level [-R]] [-P pattern] [-I pattern] 
#   [-o filename] [--version] [--help] [--inodes]
#	[--device] [--noreport] [--nolinks] [--dirsfirst] [--charset charset]
#	[--filelimit #] [<directory list>]
#  -a            All files are listed.
#  -d            List directories only.
#  -l            Follow symbolic links like directories.
#  -f            Print the full path prefix for each file.
#  -i            Don't print indentation lines.
#  -q            Print non-printable characters as '?'.
#  -N            Print non-printable characters as is.
#  -p            Print the protections for each file.
#  -u            Displays file owner or UID number.
#  -g            Displays file group owner or GID number.
#  -s            Print the size in bytes of each file.
#  -h            Print the size in a more human readable way.
#  -D            Print the date of last modification.
#  -F            Appends '/', '=', '*', or '|' as per ls -F.
#  -v            Sort files alphanumerically by version.
#  -r            Sort files in reverse alphanumeric order.
#  -t            Sort files by last modification time.
#  -x            Stay on current filesystem only.
#  -L level      Descend only level directories deep.
#  -A            Print ANSI lines graphic indentation lines.
#  -S            Print with ASCII graphics indentation lines.
#  -n            Turn colorization off always (-C overrides).
#  -C            Turn colorization on always.
#  -P pattern    List only those files that match the pattern given.
#  -I pattern    Do not list files that match the given pattern.
#  -H baseHREF   Prints out HTML format with baseHREF as top directory.
#  -T string     Replace the default HTML title and H1 header with string.
#  -R            Rerun tree when max dir level reached.
#  -o file       Output to file instead of stdout.
#  --inodes      Print inode number of each file.
#  --device      Print device ID number to which each file belongs.
#  --noreport    Turn off file/directory count at end of tree listing.
#  --nolinks     Turn off hyperlinks in HTML output.
#  --dirsfirst   List directories before files.
#  --charset X   Use charset X for HTML and indentation line output.
#  --filelimit # Do not descend dirs with more than # files in them.
#============================================================================

#cp specified files with their original dirs.
#find . -name "*.c" | xargs tar -cvf tmp.tar
#tar -xvf tmp.tar -C dest_dir
#============================================================================

#lowercase/uppercase
#str=heLlooooooo
#echo ${str^}
#echo ${str^^}
#echo ${str//[a/Oi}
#echo ${str,,}
#declare -l toLowercase
#declare -u toUppercase
#toLowercase=$str
#toUppercase=$str
#echo $toLowercase $toUppercase
#============================================================================

#copy all image files to ONE_PLACE
#searchDirs='.'
#ignorDirs='./linux-2.6/'
#imageExts=' BMP PCX TIFF GIF JPEG TGA EXIF FPX SVG CGM PSD WMF CDR EMF 
#            PICTPCD DXF UFO EPS AI PNG HDRI RAW JPG AAE MOV MP4'
#
##1 generate FIND_CMD
#
#for wkdir in $searchDirs; do
#    #1.1 init
#    set -- 
#    unset -v hasIgnorPortion
#    findCmd="find $wkdir "
#
#    #1.2 append ignore_portion
#    [[ -n $ignorDirs ]] && {
#        set $ignorDirs
#        for ((i = 1 ; i <= $# ; i++)); do
#            [[ i -gt 1 ]] && findCmd+="-o "
#            findCmd+="-ipath ${!i}\* -prune "
#        done
#        hasIgnorPortion=1
#    }
#
#    #1.3 append search_portion
#    [[ -n $imageExts ]] && {
#        set $imageExts
#        for ((i = 1 ; i <= $# ; i++)); do
#            [[ i -gt 1 || -n $hasIgnorPortion ]] && findCmd+="-o "
#            findCmd+="-iname \*.${!i} -print "
#        done
#    }
#
#    #2. execute the FIND_CMD
#    echo "$0" >> dbg.log
#    echo "$findCmd" >> dbg.log
#    echo $findCmd | bash
#done
#============================================================================
#function doExit()
#{
#    printf -- "-----\nbye $1\n"
#    exit $1
#}
#
#function selectYNS()
#{
##$1 message
##$2 default selection
##`Y' return 0, `N' return 1, `S' return 2, otherwise retrns $_NEED_CHECK_FLOW
#
#    local _replay _return
#
#    while read -t 5 -n1 -s -p "$1 $2"$'\010' _replay
#    do
#        _replay=`echo $_replay | tr a-z A-Z`
#
#        case $_replay in
#            Y|N|S) 
#                break ;;
#            ) clear; unset _replay ;;
#            * ) printf "$_replay\n! only 'Yes' or 'No' or 'Skip' is accepted!!\n"; 
#                unset _replay ;;
#        esac
#    done < /dev/tty
#
#    printf "${_replay:=$2}\n"
#    case $_replay in
#        Y) _return=0 ;;
#        N) _return=1 ;;
#        S) _return=2 ;;
#        *) _return=$_NEED_CHECK_FLOW ;;
#    esac
#
#    return $_return
#}
#
#
#declare -r _NEED_CHECK_FLOW=10
#
#while read _size _ext
#do
##generate .list
#    printf -- "-----\n$_ext $_size\n"
#    sed -n /\\."$_ext"/p RESULT > .list && echo ".list has been generated successfully"
#    nl .list | tail
#
##waiting for your decision~
#    selectYNS '> Do you want to process this? [Y/N/S]' 'Y'
#    case $? in
#        0) ;;           #yes
#        1) break ;;     #no
#        2) continue ;;  #skip
#        *) doExit $_NEED_CHECK_FLOW ;;
#    esac
#
##make tar
#    echo "Maybe you should go and have a cup of Tee:)"
#    time tar -cf tmp.tar -T .list
#
##extract from tar
#    time tar -xvf tmp.tar -C myLib >.log 2>&1
#
##check result
#    vim -d .log .list </dev/tty
#
##waiting for your decision~
#    selectYNS '> Let`s continue the job? [Y/N/S]' 'N'
#    case $? in
#        0) ;;           #yes
#        1) break ;;     #no
#        2) continue ;;  #skip
#        *) doExit $_NEED_CHECK_FLOW ;;
#    esac
#
#done < exts.proc
#
#doExit 0
#============================================================================

#arrange images by date
#
##0. init
# _workdir='myLib'
#_dir=''
#_filename=''
#
##1. list all images
##1.1 list all files
#find $_workdir -type f | sed '/\.tar$/d' >.list
#
##1.2 generate image list
#exts=`cat ext.p`
#for i in $exts
#do
#   filter+="|\.$i\$" 
#done
#grep -iE "JUST_FOR_PATTING_${filter}" .list >.list.p
#
##2. move image to the their own directories
#while read x
#do
##2.1 generate the dir_name according pic's created date
#    _content="`stat \"$x\" -c%y`"
#    _dir=${_content%% *}
#
##2.2 generate the file_name according hash value
#    _filename="`shasum \"$x\"`"
#    _filename=${_filename%% *}
#
##2.3 make the dir and mv the file to it
#    [[ -d "$_workdir/$_dir" ]] || mkdir "$_workdir/$_dir"
#    mv "$x" $_workdir/$_dir/$_filename &&
#    echo [done] mv "$x" into "$_workdir/$_dir/$_filename" ||
#    echo [fail] mv "$x" into "$_workdir/$_dir/$_filename" ;
#
#done <.list.p
#
##3. ...
#
#============================================================================

#arrange images by date
function logThis()
{
#Parameters:
#   $1, log message
#   $2, if exist, prints to standard output
    echo "$1" >>"$_tmpLogFile"
    [[ $2 == '-p' ]] && echo "$1"
    return $? ;
}

function execThis()
{
#Parameters:
#   $1, the command
    echo "$1" |bash
    return $? ;
}

#init
_sourceDirs=$1
_workDir=$2
_cmd4HashSum='shasum'
#
_tmpFile=".t"
_tmpFile2=".t2"
_tmpLogFile=".log"
_tmpSeedsFile=".seed"
_tmpListFile=".list"
_indexFile="${_workDir%%/}/.INDEX"
_idc=('/' '-' '\' '|')
_tmpStr=''
_cmd=''

#start routine
#
#0. checking parameters, start log, hide cursor
[[ -z $1 || -z $2 ]] && 
    showErr "Usage:\n  ${0##*/} sourDir destDir\n" && 
    exit 1
[[ ! -d $1 || ! -d $2 ]] &&
    showWarn "Warning:\nsourDir or destDir MUST be a directory!!\n" &&
    exit 1
:>$_tmpSeedsFile && :>$_tmpListFile && 
    :>$_tmpFile && :>$_tmpFile2 && :>>$_tmpLogFile || 
    showErr "Fail to creat one of following temporary files:
        \r\t$_tmpLogFile
        \r\t$_tmpFile
        \r\t$_tmpFile2
        \r\t$_tmpSeedsFile
        \r\t$_tmpListFile"
logThis $'\n----------------------------------------- '"[$(date)]" -p >&2
#   hideCursor

#1. list all images
#
#1.1 list all files
    showNor " *  |searching..." 
    _cmd="find '$_sourceDirs' -type f >$_tmpFile"
    logThis "$_cmd"
    execThis "$_cmd"
    showNor "\rdone\n" 
#
#1.2 select the files which to be processing according Extensions.
    showNor " *  |select the types which you want to proceed to" 
    _cmd="
        cat $_tmpFile |sed 's/^.*\.//' |sort -u >$_tmpFile2 ;
        :>$_tmpSeedsFile ;
        vim -c'
            execute setline(1, \"# list all Extensions of found files here\") |
            execute setline(2, \"# remove those which you do not want to proceed\") |
            execute setline(3, \"# after having done this, remove these prompt message\") |
            execute setline(4, \"# then, do saving&quiting to let processing continue\") |
            execute line(\"$\") |
            read ${_tmpFile2} |
            execute line(\"^\")' $_tmpSeedsFile</dev/tty ;"
    logThis "$_cmd"
    execThis "$_cmd"
    showNor "\rdone\n" 
#
#1.3 extract images & videos
#
    _filter=''
#
    showNor " *  |filter images & videos" 
    for i in $(cat "$_tmpSeedsFile"); do
        _filter+="|\.$i\$"
    done
    _cmd="grep -iE 'JUST_FOR_PATTING_${_filter}' $_tmpFile >$_tmpListFile"
    logThis "$_cmd"
    execThis "$_cmd"
    showNor "\rdone\n" 

#2. move images & videos to the the LIB
#
    _dir=''
    _file=''
#
    showNor " *  |moving images & videos\n" 
    while read x; do
        _tmpStr=$($_cmd4HashSum -b "$x") ; 
        _tmpStr=${_tmpStr%% *}
        _dir=${_tmpStr:0:2} ; 
        _file=${_tmpStr:2}
        _tmpStr="$_workDir/$_dir/$_file"
        _cmd="mv -n '$x' '$_tmpStr'"
        showNor "\r ${_idc[i++%4]}  |$_cmd$ctrl_k" 
        [[ -f "$_tmpStr" ]] && mvCursor g 12 && showFail "$x == $_tmpStr\n" >&2 && continue;
        [[ -d "$_workDir/$_dir" ]] || mkdir "$_workDir/$_dir"
        logThis "$_cmd"
        execThis "$_cmd"
    done <$_tmpListFile
    mvCursor u
    showNor "\rdone\n\rdone\n" 

#3. make indexing
#   the format of content from .log is:
#   mv -n ``source" "dest_named_by_hashcode"
#   mv -n "A" "B"
#   `A' is source file name, may include `"'
#   `B' is the destination file, named by its own hash-code
#   we need extractor the Extension of `A' and concatenate with `B'.
#   as `A' may include `"', substitute all `"' out of `A' is a good idea
#   first, remove _head and _tail.  <-- easy to do
#   then we get ``A_middleB" ,save it to the hold place of ``sed",
#   next, remove _middle an `B'.
#   It's easy to approach as `B' has such a reqular name.
#   now, we get the `A', the hardest part to extractor :)
#   ...
#
    _head="^mv -n '"
    _middle="' '"
    _tail="'$"
#
    showNor " *  |making index" 
    sed -En "
    /$_head/{
        s/$_head|$_tail//g
        h
        s/^.*$_middle//
        x
        s/$_middle[^ ]*$//
        s/^.*\.//
        H
        x
        s/\n/./
        p
    } " $_tmpLogFile >>"$_indexFile"
#
    _cmd="
        sort -u $_indexFile >$_tmpFile ;
        cp $_tmpFile $_indexFile ;"
    logThis "$_cmd"
    execThis "$_cmd"
    showNor "\rdone\n" 
#

#z. make the workdir clean
#rm $_tmpListFile
#rm $_tmpSeedsFile
#rm $_tmpLogFile
    rm $_tmpFile
    rm $_tmpFile2
    showHi "
    \r  $_tmpSeedsFile <- file types shall be processed
    \r  $_tmpListFile <- files shall be processed
    \r  $_tmpLogFile  <- runing log\n"
    showWarn "  The above 3 files are processing logs. you can remove them safety.\n" 
#
    showHi "
    \r  $_indexFile <- pic&vid database\n" 
    showWarn "  The .INDEX file is very important.\n" 
    showErr "  DO NOT remove it!!\n\n" 
    
#
#   showCursor
#============================================================================

#check the functional of \033[N`x', which `x' will change from a~z & A~Z
#function show()
#{
#    echo -ne "\033[$1;$2H$3"
#    return $?
#}
#
#echo -ne "\033[2J"
#
#declare -i x y
#
#for ((x = 1;x<=43;x++)) {
#    for ((y=0;y<=160;y+=10)){
#        [[ $x -eq 1 ]] && str=$y || str=.
#        [[ $y -eq 0 && ${x##?} -eq 0 ]] && str=$x
#        echo -ne "\033[${x};${y}H${str%%0}"
#    }
#}
#
#show 10 50 X
#show 30 100 X
#show 30 100
#x=10
#for dir in {A..Z}
#do
#    read -n1 c
#    echo -ne "\033[$x$dir$dir----------"
#    show 30 100 X
#done
#============================================================================


