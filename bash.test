#! /bin/bash

color_0=$'\e[0m'
color_1=$'\e[4;41;33m'

#definitions
#token
#    A sequence of characters considered a single unit by the shell. It
#    is either a word or an operator.
#metacharacter
#    A character that, when unquoted, separates words. A metacharacter
#    is a space, tab, newline, or one of the following characters: 
#    `|', `&', `;', `(', `)', `<', or `>'.
#word
#    A sequence of characters treated as a unit by the shell. Words may
#    not include unquoted metacharacters.
#name
#    A word consisting solely of letters, numbers, and underscores, and
#    beginning with a letter or underscore. Names are used as shell
#    variable and function names. Also referred to as an identifier.
#operator
#    A control operator or a redirection operator. See Redirections, for
#    a list of redirection operators. Operators contain at least one
#    unquoted metacharacter.
#control operator
#    A token that performs a control function. It is a newline or one of
#    the following: `||', `&&', `&', `;', `;;', `;&', `;;&', `|', `|&',
#    `(', or `)'.
#field
#    A unit of text that is the result of one of the shell expansions.
#    After expansion, when executing a command, the resulting fields are
#    used as the command name and arguments.
#Simple Commands
#    A simple command is the kind of command encountered most often. 
#    It's just a sequence of words separated by blanks, 
#    terminated by one of the shell's control operators. 
#    The first word generally specifies a command to be executed, 
#    with the rest of the words being that command's arguments.
#    The return status  of a simple command is its exit status as provided by 
#    the POSIX 1003.1 waitpid function, 
#    or 128+n if the command was terminated by signal n.
#Lists of Commands
#    A list is a sequence of one or more pipelines separated by one of the
#    operators `;', `&', `&&', or `||', 
#    and optionally terminated by one of `;',`&', or a newline.
#    Of these list operators, `&&' and `||' have equal precedence, 
#    followed by `;' and `&', which have equal precedence.
#============================================================================

#shell operation
#   The following is a brief description of the shell's operation when it 
#   reads and executes a command. Basically, the shell does the following:
#
#    1. Reads its input from a file, from a string supplied as an argument to 
#       the -c invocation option, or from the user's terminal.
#    2. Breaks the input into words and operators, obeying the quoting rules.
#       These tokens are separated by metacharacters.
#       Alias expansion is performed by this step.
#    3. Parses the tokens into simple and compound commands.
#    4. Performs the various shell expansions, breaking the expanded tokens 
#       into lists of filenames and commands and arguments.
#    5. Performs any necessary redirections and removes the 
#       redirection operators and their operands from the argument list.
#    6. Executes the command.
#    7. Optionally waits for the command to complete and 
#       collects its exit status.
#============================================================================

#quoting
#escape character
#    a non-quoted backslash `\' is the Bash escape character.
#    It preserves the literal value of the next character than follows, with
#    the exception of newline.
#    If a \newline pair appears, and the backslash iterslef is not quoted,
#    the \newline is treated as a line conitnuation.
#signal quotes
#    ignore all special meanings.
#double quotes
#    Enclosing characters in double quotes (`"') preserves the 
#    literal value of all characters within the quotes, with the exception of 
#    `$', ``', `\', `!'(when history expansion is enabled).
#    When the shell is in POSIX mode, the `!' 
#    has no special meaning within double quotes, even when 
#    history expansion is enabled. 
#    The character `$' and ``' retain their special meaning within double quotes.
#    The backslash '\' retains its special meaning only when 
#    followed by one of the following characters: `$', ``', `"', `\', or newline. 
#    Within double quotes, backslashes that 
#    are followed by one of these characters are removed.
#    Backslashes preceding characters 
#    without a special meaning are left unmodified. 
#    A double quote may be quoted within double quotes by 
#    preceding it with a backslash. 
#    If enabled, history expansion will be performed unless
#    an `!' appearing in double quotes is escaped using a backslash. 
#    The backslash preceding the `!' is not removed.
#ANSI-C quoting
#    $'string' ...
#locale-specific translation
#    $"string" ...
#============================================================================

#shell expansions
#Expansion is performed on the command line after it has been split into tokens. 
#There are seven kinds of expansion performed:
# * brace expansion
# * tilde expansion
# * parameter and variable expansion
# * arithmetic expansion
# * command substitution
# * word splitting
# * filename expansion
# * quote removal (after all expansions)
#
#Only brace expansion, word splitting, and filename expansion can 
#change the number of words of the expansion; 
#other expansions expand a single word to a single word. 
#The only exceptions to this are the expansions of "$@"  and "${name[@]}".
#
#brace expansion ...
#tilde expansion ...
#parameter expansion 
#    ${parameter:-word} ...
#    ${parameter:+word} ...
#    ${parameter:=word} ...
#    ${parameter:?word} ...
#    ${parameter:offset} ...
#    ${parameter:offset:length} ...
#    ${#parameter} ...
#    ${parameter#word} ...
#    ${parameter##word} ...
#    ${parameter%word} ...
#    ${parameter%%word} ...
#    ${parameter/pattern/string} ...
#    ${parameter//pattern/string} ...
#    ${parameter^pattern} ...
#    ${parameter^^pattern}  ...
#    ${parameter,pattern} ...
#    ${parameter,,pattern}  ...
#    ${@:offset:length} ...
#    ${arry[@]:offset:length} ...
#    ${!prefix*} ...
#    ${!name[*]} ...
#    ...
#arithmetic expansion 
#    $(( expression )) ...
#command substitution
#    $(command) ...
#    `command` ...
#word splitting
#    The shell scans the results of parameter expansion, 
#    command substitution, and arithmetic expansion that 
#    did not occur within double quotes for word splitting.
#    Note that if no expansion occurs, no splitting is performed.
#filename expansion ...
#quote removal ...
#============================================================================

#redirection
#[n]<word redirecting input
#[n]>word redirecting output
#[n]>&digit- copy digital descriptor to n and close digital descriptor
#[n]<&digit- copy digital descriptor to n and close digital descriptor
#============================================================================

#here document
#[n]<<[-]word
#       here-document
#delimiter
#here string
#[n]<<< word
#============================================================================

#function
#function hi()
#{
#echo $#,$0,$1
#echo ${FUNCNAME[*]}
#return 0   #return -1  `-1' will be regard as an option of cmd `return'
#}
#echo $#,$0,$1
#hi a b
#============================================================================

#declare
#declare variables and/or give them attributes. 
#usages:
#   1)declare [-aAfFgilrtux] 
#   2)declare -p [variable ...]
#   3)declare [-+aAfFgilrtux] [name[=value] ...]
#usage_1, list definitions(variables or funcitons) which matched the attrs
#         if no arguments represents, all definitions will be listed.
#usage_2, display the attributes of each variable
#usage_3, set/unset attributes for each name(variables or functions)
#options:
#   -p      will dispaly the attributes and values of each name
#   -a      array
#   -A      associative array
#   -f      function
#   -F      function name only
#   -i      integer
#   -l      to lower-case, once assigned a value, set all to lower-case
#   -u      to upper-case
#   -r      readonly, cannot be unset or assigned
#   -x      export to subsequent commands
#   -g      global?
#   -t      set trace attribute. (DEBUG/RETURN/... traps) 
#declare -a      #list all array
#declare -A      #list all associative array
#declare -F      #list all functions, only attribute and name displayed.
#declare -f fun_1 fun_2      #add `function' attribute to fun_1 and fun_2
#i=1; j=2; declare -p i j    #display the attributes of variable: i and j
#declare -ir +x va=3 #set va to `integer'&`readonly' and remove `export' attr
#============================================================================

#select
#select name in QUIT *; do 
#	echo "you select ($REPLY)"
#	if [ $REPLY -eq 1 ]; then
#		echo bye bye
#		break
#	fi
#	echo $color_1"ls $name"$color_0
#	ls $name
#done
#============================================================================

#read
#read x y <<< 1\ 2
#echo '$x='$x,'$y='$y
#============================================================================

#set
#set a b c d e && echo "$# $*"  #set arguments ($0,$1,...)
#set -- && echo "$#"            #unset positional arguments
#set -x                         #open debug
#set +x                         #close debug
#============================================================================

#case
#cat <<< "'q' to quit"
#while read i
#do
#	case $i in
#	*) echo "you have input $color_1'$i'$color_0, go on" ;;&	# use ;;&
#	a) echo 'here is a, stop' ;;								# use ;;
#	b) echo 'here is b, have a rest and go on' ;&				# use ;&
#	c) echo 'here is c, stop' ;;
#	d) echo 'here is d, stop' ;;
#	q) echo 'here is q, bye.bye' ; break ;;
#	esac
#done
#============================================================================

#checking if any branch hasn't pushed to remote
#
#_branches=`git branch | sed 's/\** *//g'`
#
#_errlog="err.log"
#_done='\033[0;40;32m[done]\033[0m'
#_fail='\033[0;40;31m[fail]\033[0m'
#
#for i in $_branches; do
#	cmd="git diff $i origin/$i"
# 	{ 	
#		rm -f $i.diff 
#		$cmd > $i.diff &&
#		echo -e "$_done $i" || ( 
#		echo -e "$_fail $i --> $_errlog" && echo -e "* $cmd" >&2 )
#		} 2>>$_errlog
#done
#
#for i in $_branches; do
#	if [[ -s $i.diff ]] ; then
#		if [[ _first -eq 0 ]] ; then
#			_first=1 && echo -e "\nFollowing branches has not pushed to remote"
#		fi
#		echo "* $i"
#	fi
#done
#============================================================================

#test, -v varname returns TRUE if varname is set
#set tmp
#unset tmp
#[[ -v tmp ]] && echo 'variable ``tmp" is set'
#[[ $tmp == "" ]] && echo 'variable ``tmp" is empty'		# not safe
#tmp="hi, i have been set a value"
#echo ${tmp:?"tmp is unset or null"}
#============================================================================

#history
#history components include 3 portions:
#1) EVENT, expand to a history item
#2) WORD, selects some words from the history item
#3) MODIFIER, manipulate on the words
#about EVENT,
#!!                  expand to last command
#!n                  expand to the `nth' command
#!-n                 expand to the last_minus_n command
#!string             expand to the last command preceding with the `string'
#!?string?           expand to the last command including the `string'
#^string1^string2^   substitute the last command
#!#                  i don't known
#
#about WORD,
#:n                  select the `nth' word (start with 0)
#:^                  select the first argument
#:$                  select the last argument
#:%                  the word matched by the most recent `?string?' search
#:x-y                select the from `xth' to `yth'
#:*                  :1-$
#:x*                 :x-$
#:x-                 i am not sure...
#
#about MODIFIER,
#:h                  HEAD, when there is filename with path, 
#                    remove the filename and the contents following it
#:t                  TAIL, ..., remove the contents above the filename
#:r                  REGULAR, ...
#:e                  EXTENSION, ...
#:p                  PRINT, ...
#:...                can `man history'
#
#ls -al bash.test    # once executed, system saves this CMD to history
#!!:0                # execute ``ls"
#!!:^                # execute ``-al"
#!!:$                # execute ``bash.test"
#!!:1-$              # execute ``-al bash.test"
#!!:0*               # execute ``ls -al bash.test"
#!!:0:p              # print `ls'
#!!:$:p              # print `bash.test'
#!!:^*:p             # print `-al bash.test'
#============================================================================

#tree
#usage: tree [-adfghilnpqrstuvxACDFNS] [-H baseHREF] [-T title ] 
#   [-L level [-R]] [-P pattern] [-I pattern] 
#   [-o filename] [--version] [--help] [--inodes]
#	[--device] [--noreport] [--nolinks] [--dirsfirst] [--charset charset]
#	[--filelimit #] [<directory list>]
#  -a            All files are listed.
#  -d            List directories only.
#  -l            Follow symbolic links like directories.
#  -f            Print the full path prefix for each file.
#  -i            Don't print indentation lines.
#  -q            Print non-printable characters as '?'.
#  -N            Print non-printable characters as is.
#  -p            Print the protections for each file.
#  -u            Displays file owner or UID number.
#  -g            Displays file group owner or GID number.
#  -s            Print the size in bytes of each file.
#  -h            Print the size in a more human readable way.
#  -D            Print the date of last modification.
#  -F            Appends '/', '=', '*', or '|' as per ls -F.
#  -v            Sort files alphanumerically by version.
#  -r            Sort files in reverse alphanumeric order.
#  -t            Sort files by last modification time.
#  -x            Stay on current filesystem only.
#  -L level      Descend only level directories deep.
#  -A            Print ANSI lines graphic indentation lines.
#  -S            Print with ASCII graphics indentation lines.
#  -n            Turn colorization off always (-C overrides).
#  -C            Turn colorization on always.
#  -P pattern    List only those files that match the pattern given.
#  -I pattern    Do not list files that match the given pattern.
#  -H baseHREF   Prints out HTML format with baseHREF as top directory.
#  -T string     Replace the default HTML title and H1 header with string.
#  -R            Rerun tree when max dir level reached.
#  -o file       Output to file instead of stdout.
#  --inodes      Print inode number of each file.
#  --device      Print device ID number to which each file belongs.
#  --noreport    Turn off file/directory count at end of tree listing.
#  --nolinks     Turn off hyperlinks in HTML output.
#  --dirsfirst   List directories before files.
#  --charset X   Use charset X for HTML and indentation line output.
#  --filelimit # Do not descend dirs with more than # files in them.
#============================================================================

#cp specified files with their original dirs.
#find . -name "*.c" | xargs tar -cvf tmp.tar
#tar -xvf tmp.tar -C dest_dir
#============================================================================

#lowercase/uppercase
#str=heLlooooooo
#echo ${str^}
#echo ${str^^}
#echo ${str//[a/Oi}
#echo ${str,,}
#declare -l toLowercase
#declare -u toUppercase
#toLowercase=$str
#toUppercase=$str
#echo $toLowercase $toUppercase
#============================================================================

#copy all image files to ONE_PLACE
#searchDirs='.'
#ignorDirs='./linux-2.6/'
#imageExts=' BMP PCX TIFF GIF JPEG TGA EXIF FPX SVG CGM PSD WMF CDR EMF 
#            PICTPCD DXF UFO EPS AI PNG HDRI RAW JPG AAE MOV MP4'
#
##1 generate FIND_CMD
#
#for wkdir in $searchDirs; do
#    #1.1 init
#    set -- 
#    unset -v hasIgnorPortion
#    findCmd="find $wkdir "
#
#    #1.2 append ignore_portion
#    [[ -n $ignorDirs ]] && {
#        set $ignorDirs
#        for ((i = 1 ; i <= $# ; i++)); do
#            [[ i -gt 1 ]] && findCmd+="-o "
#            findCmd+="-ipath ${!i}\* -prune "
#        done
#        hasIgnorPortion=1
#    }
#
#    #1.3 append search_portion
#    [[ -n $imageExts ]] && {
#        set $imageExts
#        for ((i = 1 ; i <= $# ; i++)); do
#            [[ i -gt 1 || -n $hasIgnorPortion ]] && findCmd+="-o "
#            findCmd+="-iname \*.${!i} -print "
#        done
#    }
#
#    #2. execute the FIND_CMD
#    echo "$0" >> dbg.log
#    echo "$findCmd" >> dbg.log
#    echo $findCmd | sh
#done
#============================================================================
