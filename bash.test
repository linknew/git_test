#! /bin/bash

ctrl_k=$'\e[K'
#
#
#functions for cursor operating
#
function _mvCursor()
{
#Descriptions:
#   move cursor.
#Parameters:
#   $1, the direction of moving.
#       `l' move left,   mapping to \033[D
#       `r' move righ,   mapping to \033[C
#       `u' move up,     mapping to \033[A
#       `d' move down,   mapping to \033[B
#       `g' goto column, mapping to \033[G
#       `j' jump to x;y, mapping to \033[H
#   $2, count of repeats for line
#   $3, the value of `y' for jump to ``x;y"
#
#
    local _direction=`echo $1 | tr ludgjr DABGHC`
    echo -ne "\033[${2:-1}${3:+;$3}${_direction}"
}
function cursorLeft()
{
    _mvCursor l $1
}
function cursorRight()
{
    _mvCursor r $1
}
function cursorUp()
{
    _mvCursor u $1
}
function cursorDown()
{
    _mvCursor d $1
}
function cursorHor()
{
    _mvCursor g $1
}
function cursorTo()
{
    _mvCursor j $1 $2
}

#
#
function hideCursor()
{
    echo -n $'\e[?25l'
}
#
#
function showCursor()
{
    echo -n $'\e[?25h'
}
#
#
function saveCursor()
{
    echo -n $'\e[s'
}
#
#
function restoreCursor()
{
    echo -n $'\e[u'
}
#
#
function blinkCursor()
{
    local _x
#
    while ture; do
        hideCursor
        sleep 0.1
        showCursor
        read -s -n1 -t1 _x </dev/tty && break
    done
    echo _x
}
#
#
function getCurPos()
{
    exec </dev/tty
    _bakTTY=$(stty -g)
    stty raw -echo min 0
    echo -n $'\e[6n' >/dev/tty
    read -dR pos
    stty $_bakTTY
    echo "${pos##*[}"
}
#============================================================================

#functions for screen operating.
function _clrScr()
{
#Descriptions:
#   clear screen, using ANSI $'\e[nJ'
#Parameters:
#   $1, clearing type
#       `a' clearing above, mappint to `1'
#       `b' clearing below, mappint to `0'
#       `h' clearing whole screen, mappint to `2'  <-- the default
#
    local _type=`echo $1 | tr abh 102`
    echo -ne "\e[${_type}J"
}
function clrScr()
{
    _clrScr h
}
function clrUpScr()
{
    _clrScr a
}
function clrDnScr()
{
    _clrScr b
}
#
#
function clrInLine()
{
#Descriptions:
#   clear in current line, using ANSI $'\e[nK'
#Parameters:
#   $1, clearning type
#       `a' clearing above(to head), mapping to `1'
#       `b' clearing below(to tail), mapping to `0' <-- the default
#       `h' clearing whole line, mapping to `2'
#   
    local _type=`echo $1 | tr ahb 120`
    echo -ne "\e[${_type}K"
}
function clrLine()
{
    _clrInLine h
}
function clrHeadLine()
{
    _clrInLine a
}
function clrTailLine()
{
    _clrInLine b
}
#
#
function _scrlScr()
{
#Descriptions:
#   scroll screen, using ANSI $'\e[nS' for up and $'\e[nT' for down
#Parameters:
#   $1, scroll type
#       `u' scroll up, mapping to `S'
#       `d' scroll down, mapping to `T'
#   $2, scroll line numbers
#   
    local _type=`echo $1 | tr ud ST`
    echo -ne "\e[${2:-1}${_type}"
}
#============================================================================

#functions for functional message displaying
function _showMsg()
{
#Descriptions:
#   display functional messages such as Warning,Error,Fail...
#   implement by useing ``echo -ne"
#   caller should handle the format issues.
#   insert `\r' `\n' etc. in the message to control the format
#Parameters:
#   $1, message type
#       `N'     normal message
#       `H'     highlight message
#       `W'     warning message
#       `E'     error message
#       `F'     failure message
#       `S'     success message
#   $2, message content
#   
    local _msgType=$1
    local _color=''
    local -r _colrN=$'\e[0m'
#
    case $_msgType in
    H|h) _color=$'\e[1;36m' ;;
    W|w) _color=$'\e[1;33m' ;;
    E|e) _color=$'\e[1;31m' ;;
    S|s) _color=$'\e[7;32m' ;;
    F|f) _color=$'\e[7;31m' ;;
    *)   _color=$'\e[0m' ;;
    esac
#
    echo -ne "$_color$2$_colrN"
}
#
function showMsg()
{
    _showMsg N $1
}
function showNor()
{
    _showMsg N $1
}
function showHi()
{
    _showMsg H $1
}
function showWarn()
{
    _showMsg W $1
}
function showErr()
{
    _showMsg E $1
}
function showOk()
{
    _showMsg S $1
}
function showFail()
{
    _showMsg F $1
}
#============================================================================

#definitions
#token
#    A sequence of characters considered a single unit by the shell. It
#    is either a word or an operator.
#metacharacter
#    A character that, when unquoted, separates words. A metacharacter
#    is a space, tab, newline, or one of the following characters: 
#    `|', `&', `;', `(', `)', `<', or `>'.
#word
#    A sequence of characters treated as a unit by the shell. Words may
#    not include unquoted metacharacters.
#name
#    A word consisting solely of letters, numbers, and underscores, and
#    beginning with a letter or underscore. Names are used as shell
#    variable and function names. Also referred to as an identifier.
#operator
#    A control operator or a redirection operator. See Redirections, for
#    a list of redirection operators. Operators contain at least one
#    unquoted metacharacter.
#control operator
#    A token that performs a control function. It is a newline or one of
#    the following: `||', `&&', `&', `;', `;;', `;&', `;;&', `|', `|&',
#    `(', or `)'.
#field
#    A unit of text that is the result of one of the shell expansions.
#    After expansion, when executing a command, the resulting fields are
#    used as the command name and arguments.
#Simple Commands
#    A simple command is the kind of command encountered most often. 
#    It's just a sequence of words separated by blanks, 
#    terminated by one of the shell's control operators. 
#    The first word generally specifies a command to be executed, 
#    with the rest of the words being that command's arguments.
#    The return status  of a simple command is its exit status as provided by 
#    the POSIX 1003.1 waitpid function, 
#    or 128+n if the command was terminated by signal n.
#Lists of Commands
#    A list is a sequence of one or more pipelines separated by one of the
#    operators `;', `&', `&&', or `||', 
#    and optionally terminated by one of `;',`&', or a newline.
#    Of these list operators, `&&' and `||' have equal precedence, 
#    followed by `;' and `&', which have equal precedence.
#============================================================================

#shell operation
#   The following is a brief description of the shell's operation when it 
#   reads and executes a command. Basically, the shell does the following:
#
#    1. Reads its input from a file, from a string supplied as an argument to 
#       the -c invocation option, or from the user's terminal.
#    2. Breaks the input into words and operators, obeying the quoting rules.
#       These tokens are separated by metacharacters.
#       Alias expansion is performed by this step.
#    3. Parses the tokens into simple and compound commands.
#    4. Performs the various shell expansions, breaking the expanded tokens 
#       into lists of filenames and commands and arguments.
#    5. Performs any necessary redirections and removes the 
#       redirection operators and their operands from the argument list.
#    6. Executes the command.
#    7. Optionally waits for the command to complete and 
#       collects its exit status.
#============================================================================

#quoting
#escape character
#    a non-quoted backslash `\' is the Bash escape character.
#    It preserves the literal value of the next character than follows, with
#    the exception of newline.
#    If a \newline pair appears, and the backslash iterslef is not quoted,
#    the \newline is treated as a line conitnuation.
#signal quotes
#    ignore all special meanings.
#double quotes
#    Enclosing characters in double quotes (`"') preserves the 
#    literal value of all characters within the quotes, with the exception of 
#    `$', ``', `\', `!'(when history expansion is enabled).
#    When the shell is in POSIX mode, the `!' 
#    has no special meaning within double quotes, even when 
#    history expansion is enabled. 
#    The character `$' and ``' retain their special meaning within double quotes.
#    The backslash '\' retains its special meaning only when 
#    followed by one of the following characters: `$', ``', `"', `\', or newline. 
#    Within double quotes, backslashes that 
#    are followed by one of these characters are removed.
#    Backslashes preceding characters 
#    without a special meaning are left unmodified. 
#    A double quote may be quoted within double quotes by 
#    preceding it with a backslash. 
#    If enabled, history expansion will be performed unless
#    an `!' appearing in double quotes is escaped using a backslash. 
#    The backslash preceding the `!' is not removed.
#ANSI-C quoting
#    $'string' ...
#locale-specific translation
#    $"string" ...
#============================================================================

#shell expansions
#Expansion is performed on the command line after it has been split into tokens. 
#There are seven kinds of expansion performed:
# * brace expansion
# * tilde expansion
# * parameter and variable expansion
# * arithmetic expansion
# * command substitution
# * word splitting
# * filename expansion
# * quote removal (after all expansions)
#
#Only brace expansion, word splitting, and filename expansion can 
#change the number of words of the expansion; 
#other expansions expand a single word to a single word. 
#The only exceptions to this are the expansions of "$@"  and "${name[@]}".
#
#brace expansion ...
#tilde expansion ...
#parameter expansion 
#    ${parameter:-word} ...
#    ${parameter:+word} ...
#    ${parameter:=word} ...
#    ${parameter:?word} ...
#    ${parameter:offset} ...
#    ${parameter:offset:length} ...
#    ${#parameter} ...
#    ${parameter#word} ...
#    ${parameter##word} ...
#    ${parameter%word} ...
#    ${parameter%%word} ...
#    ${parameter/pattern/string} ...
#    ${parameter//pattern/string} ...
#    ${parameter^pattern} ...
#    ${parameter^^pattern}  ...
#    ${parameter,pattern} ...
#    ${parameter,,pattern}  ...
#    ${@:offset:length} ...
#    ${arry[@]:offset:length} ...
#    ${!prefix*} ...
#    ${!name[*]} ...
#    ...
#arithmetic expansion 
#    $(( expression )) ...
#command substitution
#    $(command) ...
#    `command` ...
#word splitting
#    The shell scans the results of parameter expansion, 
#    command substitution, and arithmetic expansion that 
#    did not occur within double quotes for word splitting.
#    Note that if no expansion occurs, no splitting is performed.
#filename expansion ...
#quote removal ...
#============================================================================

#assignment
#name=[value]
#All values undergo tilde expansion, parameter and variable expansion, 
#command substitution, arithmetic expansion, and quote removal. 
#Word splitting is not performed, with the exception of "$@". 
#Filename expansion is not performed. 
#============================================================================

#redirection
#[n]<word redirecting input
#[n]>word redirecting output
#[n]>&digit- copy digital descriptor to n and close digital descriptor
#[n]<&digit- copy digital descriptor to n and close digital descriptor
#[n]<&- close the specified descriptor
#[n]>&- close the specified descriptor
#============================================================================

#here document
#[n]<<[-]word
#       here-document
#delimiter
#here string
#[n]<<< word
#============================================================================

#function
#function hi()
#{
#echo $#,$0,$1
#echo ${FUNCNAME[*]}
#return 0   #return -1  `-1' will be regard as an option of cmd `return'
#}
#echo $#,$0,$1
#hi a b
#============================================================================

#declare
#declare variables and/or give them attributes. 
#usages:
#   1)declare [-aAfFgilrtux] 
#   2)declare -p [variable ...]
#   3)declare [-+aAfFgilrtux] [name[=value] ...]
#usage_1, list definitions(variables or funcitons) which matched the attrs
#         if no arguments represents, all definitions will be listed.
#usage_2, display the attributes of each variable
#usage_3, set/unset attributes for each name(variables or functions)
#options:
#   -p      will dispaly the attributes and values of each name
#   -a      array
#   -A      associative array
#   -f      function
#   -F      function name only
#   -i      integer
#   -l      to lower-case, once assigned a value, set all to lower-case
#   -u      to upper-case
#   -r      readonly, cannot be unset or assigned
#   -x      export to subsequent commands
#   -g      global?
#   -t      set trace attribute. (DEBUG/RETURN/... traps) 
#declare -a      #list all array
#declare -A      #list all associative array
#declare -F      #list all functions, only attribute and name displayed.
#declare -f fun_1 fun_2      #add `function' attribute to fun_1 and fun_2
#i=1; j=2; declare -p i j    #display the attributes of variable: i and j
#declare -ir +x va=3 #set va to `integer'&`readonly' and remove `export' attr
#============================================================================

#select
#select name in QUIT *; do 
#	echo "you select ($REPLY)"
#	if [ $REPLY -eq 1 ]; then
#		echo bye bye
#		break
#	fi
#	echo $_colrH"ls $name"$_colrN
#	ls $name
#done
#============================================================================

#read
#read x y <<< 1\ 2
#echo '$x='$x,'$y='$y
#read -n1 x             #only accept one character
#read -s x              #security
#read -p "Enter.." x    #prompt
#read -t 5 x            #time limit
#
##cannot read data from pipe with read??
#cat aFile | while read x
#do
#y+="$x"
#done
#echo $y                #`y' is empty because PIPE use different process...
##we can use:
#while read x
#do
#y+="$x"
#done < aFile           #redirect the standard input. 
#echo "$y"              #keep the read in the main process
#============================================================================

#set
#set a b c d e && echo "$# $*"  #set arguments ($0,$1,...)
#set -- && echo "$#"            #unset positional arguments
#set -x                         #open debug
#set +x                         #close debug
#base -x script
#============================================================================

#case
#cat <<< "'q' to quit"
#while read i
#do
#	case $i in
#	*) echo "you have input $_colrH'$i'$_colrN, go on" ;;&	# use ;;&
#	a) echo 'here is a, stop' ;;								# use ;;
#	b) echo 'here is b, have a rest and go on' ;&				# use ;&
#	c) echo 'here is c, stop' ;;
#	d) echo 'here is d, stop' ;;
#	q) echo 'here is q, bye.bye' ; break ;;
#	esac
#done
#============================================================================

#checking if any branch hasn't pushed to remote
#
#_branches=`git branch | sed 's/\** *//g'`
#
#_errlog="err.log"
#_done='\033[0;40;32m[done]\033[0m'
#_fail='\033[0;40;31m[fail]\033[0m'
#
#for i in $_branches; do
#	cmd="git diff $i origin/$i"
# 	{ 	
#		rm -f $i.diff 
#		$cmd > $i.diff &&
#		echo -e "$_done $i" || ( 
#		echo -e "$_fail $i --> $_errlog" && echo -e "* $cmd" >&2 )
#		} 2>>$_errlog
#done
#
#for i in $_branches; do
#	if [[ -s $i.diff ]] ; then
#		if [[ _first -eq 0 ]] ; then
#			_first=1 && echo -e "\nFollowing branches has not pushed to remote"
#		fi
#		echo "* $i"
#	fi
#done
#============================================================================

#test, -v varname returns TRUE if varname is set
#set tmp
#unset tmp
#[[ -v tmp ]] && echo 'variable ``tmp" is set'
#[[ $tmp == "" ]] && echo 'variable ``tmp" is empty'		# not safe
#tmp="hi, i have been set a value"
#echo ${tmp:?"tmp is unset or null"}
#============================================================================

#history
#history components include 3 portions:
#1) EVENT, expand to a history item
#2) WORD, selects some words from the history item
#3) MODIFIER, manipulate on the words
#about EVENT,
#!!                  expand to last command
#!n                  expand to the `nth' command
#!-n                 expand to the last_minus_n command
#!string             expand to the last command preceding with the `string'
#!?string?           expand to the last command including the `string'
#^string1^string2^   substitute the last command
#!#                  i don't known
#
#about WORD,
#:n                  select the `nth' word (start with 0)
#:^                  select the first argument
#:$                  select the last argument
#:%                  the word matched by the most recent `?string?' search
#:x-y                select the from `xth' to `yth'
#:*                  :1-$
#:x*                 :x-$
#:x-                 i am not sure...
#
#about MODIFIER,
#:h                  HEAD, when there is filename with path, 
#                    remove the filename and the contents following it
#:t                  TAIL, ..., remove the contents above the filename
#:r                  REGULAR, ...
#:e                  EXTENSION, ...
#:p                  PRINT, ...
#:...                can `man history'
#
#ls -al bash.test    # once executed, system saves this CMD to history
#!!:0                # execute ``ls"
#!!:^                # execute ``-al"
#!!:$                # execute ``bash.test"
#!!:1-$              # execute ``-al bash.test"
#!!:0*               # execute ``ls -al bash.test"
#!!:0:p              # print `ls'
#!!:$:p              # print `bash.test'
#!!:^*:p             # print `-al bash.test'
#============================================================================

#tree
#usage: tree [-adfghilnpqrstuvxACDFNS] [-H baseHREF] [-T title ] 
#   [-L level [-R]] [-P pattern] [-I pattern] 
#   [-o filename] [--version] [--help] [--inodes]
#	[--device] [--noreport] [--nolinks] [--dirsfirst] [--charset charset]
#	[--filelimit #] [<directory list>]
#  -a            All files are listed.
#  -d            List directories only.
#  -l            Follow symbolic links like directories.
#  -f            Print the full path prefix for each file.
#  -i            Don't print indentation lines.
#  -q            Print non-printable characters as '?'.
#  -N            Print non-printable characters as is.
#  -p            Print the protections for each file.
#  -u            Displays file owner or UID number.
#  -g            Displays file group owner or GID number.
#  -s            Print the size in bytes of each file.
#  -h            Print the size in a more human readable way.
#  -D            Print the date of last modification.
#  -F            Appends '/', '=', '*', or '|' as per ls -F.
#  -v            Sort files alphanumerically by version.
#  -r            Sort files in reverse alphanumeric order.
#  -t            Sort files by last modification time.
#  -x            Stay on current filesystem only.
#  -L level      Descend only level directories deep.
#  -A            Print ANSI lines graphic indentation lines.
#  -S            Print with ASCII graphics indentation lines.
#  -n            Turn colorization off always (-C overrides).
#  -C            Turn colorization on always.
#  -P pattern    List only those files that match the pattern given.
#  -I pattern    Do not list files that match the given pattern.
#  -H baseHREF   Prints out HTML format with baseHREF as top directory.
#  -T string     Replace the default HTML title and H1 header with string.
#  -R            Rerun tree when max dir level reached.
#  -o file       Output to file instead of stdout.
#  --inodes      Print inode number of each file.
#  --device      Print device ID number to which each file belongs.
#  --noreport    Turn off file/directory count at end of tree listing.
#  --nolinks     Turn off hyperlinks in HTML output.
#  --dirsfirst   List directories before files.
#  --charset X   Use charset X for HTML and indentation line output.
#  --filelimit # Do not descend dirs with more than # files in them.
#============================================================================

#cp specified files with their original dirs.
#find . -name "*.c" | xargs tar -cvf tmp.tar
#tar -xvf tmp.tar -C dest_dir
#============================================================================

#lowercase/uppercase
#str=heLlooooooo
#echo ${str^}
#echo ${str^^}
#echo ${str//[a/Oi}
#echo ${str,,}
#declare -l toLowercase
#declare -u toUppercase
#toLowercase=$str
#toUppercase=$str
#echo $toLowercase $toUppercase
#============================================================================

#copy all image files to ONE_PLACE
#searchDirs='.'
#ignorDirs='./linux-2.6/'
#imageExts=' BMP PCX TIFF GIF JPEG TGA EXIF FPX SVG CGM PSD WMF CDR EMF 
#            PICTPCD DXF UFO EPS AI PNG HDRI RAW JPG AAE MOV MP4'
#
##1 generate FIND_CMD
#
#for wkdir in $searchDirs; do
#    #1.1 init
#    set -- 
#    unset -v hasIgnorPortion
#    findCmd="find $wkdir "
#
#    #1.2 append ignore_portion
#    [[ -n $ignorDirs ]] && {
#        set $ignorDirs
#        for ((i = 1 ; i <= $# ; i++)); do
#            [[ i -gt 1 ]] && findCmd+="-o "
#            findCmd+="-ipath ${!i}\* -prune "
#        done
#        hasIgnorPortion=1
#    }
#
#    #1.3 append search_portion
#    [[ -n $imageExts ]] && {
#        set $imageExts
#        for ((i = 1 ; i <= $# ; i++)); do
#            [[ i -gt 1 || -n $hasIgnorPortion ]] && findCmd+="-o "
#            findCmd+="-iname \*.${!i} -print "
#        done
#    }
#
#    #2. execute the FIND_CMD
#    echo "$0" >> dbg.log
#    echo "$findCmd" >> dbg.log
#    echo $findCmd | bash
#done
#============================================================================
#function doExit()
#{
#    printf -- "-----\nbye $1\n"
#    exit $1
#}
#
#function selectYNS()
#{
##$1 message
##$2 default selection
##`Y' return 0, `N' return 1, `S' return 2, otherwise retrns $_NEED_CHECK_FLOW
#
#    local _replay _return
#
#    while read -t 5 -n1 -s -p "$1 $2"$'\010' _replay
#    do
#        _replay=`echo $_replay | tr a-z A-Z`
#
#        case $_replay in
#            Y|N|S) 
#                break ;;
#            ) clear; unset _replay ;;
#            * ) printf "$_replay\n! only 'Yes' or 'No' or 'Skip' is accepted!!\n"; 
#                unset _replay ;;
#        esac
#    done < /dev/tty
#
#    printf "${_replay:=$2}\n"
#    case $_replay in
#        Y) _return=0 ;;
#        N) _return=1 ;;
#        S) _return=2 ;;
#        *) _return=$_NEED_CHECK_FLOW ;;
#    esac
#
#    return $_return
#}
#
#
#declare -r _NEED_CHECK_FLOW=10
#
#while read _size _ext
#do
##generate .list
#    printf -- "-----\n$_ext $_size\n"
#    sed -n /\\."$_ext"/p RESULT > .list && echo ".list has been generated successfully"
#    nl .list | tail
#
##waiting for your decision~
#    selectYNS '> Do you want to process this? [Y/N/S]' 'Y'
#    case $? in
#        0) ;;           #yes
#        1) break ;;     #no
#        2) continue ;;  #skip
#        *) doExit $_NEED_CHECK_FLOW ;;
#    esac
#
##make tar
#    echo "Maybe you should go and have a cup of Tee:)"
#    time tar -cf tmp.tar -T .list
#
##extract from tar
#    time tar -xvf tmp.tar -C myLib >.log 2>&1
#
##check result
#    vim -d .log .list </dev/tty
#
##waiting for your decision~
#    selectYNS '> Let`s continue the job? [Y/N/S]' 'N'
#    case $? in
#        0) ;;           #yes
#        1) break ;;     #no
#        2) continue ;;  #skip
#        *) doExit $_NEED_CHECK_FLOW ;;
#    esac
#
#done < exts.proc
#
#doExit 0
#============================================================================

#arrange images by date
#
##0. init
# _workdir='myLib'
#_dir=''
#_filename=''
#
##1. list all images
##1.1 list all files
#find $_workdir -type f | sed '/\.tar$/d' >.list
#
##1.2 generate image list
#exts=`cat ext.p`
#for i in $exts
#do
#   filter+="|\.$i\$" 
#done
#grep -iE "JUST_FOR_PATTING_${filter}" .list >.list.p
#
##2. move image to the their own directories
#while read x
#do
##2.1 generate the dir_name according pic's created date
#    _content="`stat \"$x\" -c%y`"
#    _dir=${_content%% *}
#
##2.2 generate the file_name according hash value
#    _filename="`shasum \"$x\"`"
#    _filename=${_filename%% *}
#
##2.3 make the dir and mv the file to it
#    [[ -d "$_workdir/$_dir" ]] || mkdir "$_workdir/$_dir"
#    mv "$x" $_workdir/$_dir/$_filename &&
#    echo [done] mv "$x" into "$_workdir/$_dir/$_filename" ||
#    echo [fail] mv "$x" into "$_workdir/$_dir/$_filename" ;
#
#done <.list.p
#
##3. ...
#
#============================================================================

#arrange images by date
#function logThis()
#{
##Parameters:
##   $1, log message
##   $2, if exist, prints to standard output
#    echo "$1" >>"$_tmpLogFile"
#    [[ $2 == '-p' ]] && echo "$1"
#}
#
#function execThis()
#{
##Parameters:
##   $1, the command
#    echo "$1" |bash
#}
#
##init
#_sourceDirs=$1
#_workDir=$2
#_cmd4HashSum='shasum'
##
#_tmpFile=".t"
#_tmpFile2=".t2"
#_tmpLogFile=".log"
#_tmpSeedsFile=".seed"
#_tmpListFile=".list"
#_indexFile="${_workDir%%/}/.INDEX"
#_idc=('/' '-' '\' '|')
#_tmpStr=''
#_cmd=''
#
##start routine
##
##0. checking parameters, start log, hide cursor
#[[ -z $1 || -z $2 ]] && 
#    showErr "Usage:\n  ${0##*/} sourDir destDir\n" && 
#    exit 1
#[[ ! -d $1 || ! -d $2 ]] &&
#    showWarn "Warning:\nsourDir or destDir MUST be a directory!!\n" &&
#    exit 1
#:>$_tmpSeedsFile && :>$_tmpListFile && 
#    :>$_tmpFile && :>$_tmpFile2 && :>>$_tmpLogFile || 
#    showErr "Fail to creat one of following temporary files:
#        \r\t$_tmpLogFile
#        \r\t$_tmpFile
#        \r\t$_tmpFile2
#        \r\t$_tmpSeedsFile
#        \r\t$_tmpListFile"
#logThis $'\n----------------------------------------- '"[$(date)]" -p >&2
##   hideCursor
#
##1. list all images
##
##1.1 list all files
#    showNor " *  |searching..." 
#    _cmd="find '$_sourceDirs' -type f >$_tmpFile"
#    logThis "$_cmd"
#    execThis "$_cmd"
#    showNor "\rdone\n" 
##
##1.2 select the files which to be processing according Extensions.
#    showNor " *  |select the types which you want to proceed to" 
#    _cmd="
#        cat $_tmpFile |sed 's/^.*\.//' |sort -u >$_tmpFile2 ;
#        :>$_tmpSeedsFile ;
#        vim -c'
#            execute setline(1, \"# list all Extensions of found files here\") |
#            execute setline(2, \"# remove those which you do not want to proceed\") |
#            execute setline(3, \"# after having done this, remove these prompt message\") |
#            execute setline(4, \"# then, do saving&quiting to let processing continue\") |
#            execute line(\"$\") |
#            read ${_tmpFile2} |
#            execute line(\"^\")' $_tmpSeedsFile</dev/tty ;"
#    logThis "$_cmd"
#    execThis "$_cmd"
#    showNor "\rdone\n" 
##
##1.3 extract images & videos
##
#    _filter=''
##
#    showNor " *  |filter images & videos" 
#    for i in $(cat "$_tmpSeedsFile"); do
#        _filter+="|\.$i\$"
#    done
#    _cmd="grep -iE 'JUST_FOR_PATTING_${_filter}' $_tmpFile >$_tmpListFile"
#    logThis "$_cmd"
#    execThis "$_cmd"
#    showNor "\rdone\n" 
#
##2. move images & videos to the the LIB
##
#    _dir=''
#    _file=''
##
#    showNor " *  |moving images & videos\n" 
#    while read x; do
#        _tmpStr=$($_cmd4HashSum -b "$x") ; 
#        _tmpStr=${_tmpStr%% *}
#        _dir=${_tmpStr:0:2} ; 
#        _file=${_tmpStr:2}
#        _tmpStr="$_workDir/$_dir/$_file"
#        _cmd="mv -n '$x' '$_tmpStr'"
#        showNor "\r ${_idc[i++%4]}  |$_cmd$ctrl_k" 
#        [[ -f "$_tmpStr" ]] && cursorHor 12 && showFail "$x == $_tmpStr\n" >&2 && continue;
#        [[ -d "$_workDir/$_dir" ]] || mkdir "$_workDir/$_dir"
#        logThis "$_cmd"
#        execThis "$_cmd"
#    done <$_tmpListFile
#    cursorUp
#    showNor "\rdone\n\rdone\n" 
#
##3. make indexing
##   the format of content from .log is:
##   mv -n ``source" "dest_named_by_hashcode"
##   mv -n "A" "B"
##   `A' is source file name, may include `"'
##   `B' is the destination file, named by its own hash-code
##   we need extractor the Extension of `A' and concatenate with `B'.
##   as `A' may include `"', substitute all `"' out of `A' is a good idea
##   first, remove _head and _tail.  <-- easy to do
##   then we get ``A_middleB" ,save it to the hold place of ``sed",
##   next, remove _middle an `B'.
##   It's easy to approach as `B' has such a reqular name.
##   now, we get the `A', the hardest part to extractor :)
##   ...
##
#    _head="^mv -n '"
#    _middle="' '"
#    _tail="'$"
##
#    showNor " *  |making index" 
#    sed -En "
#    /$_head/{
#        s/$_head|$_tail//g
#        h
#        s/^.*$_middle//
#        x
#        s/$_middle[^ ]*$//
#        s/^.*\.//
#        H
#        x
#        s/\n/./
#        p
#    } " $_tmpLogFile >>"$_indexFile"
##
#    _cmd="
#        sort -u $_indexFile >$_tmpFile ;
#        cp $_tmpFile $_indexFile ;"
#    logThis "$_cmd"
#    execThis "$_cmd"
#    showNor "\rdone\n" 
##
#
##z. make the workdir clean
##rm $_tmpListFile
##rm $_tmpSeedsFile
##rm $_tmpLogFile
#    rm $_tmpFile
#    rm $_tmpFile2
#    showHi "
#    \r  $_tmpSeedsFile <- file types shall be processed
#    \r  $_tmpListFile <- files shall be processed
#    \r  $_tmpLogFile  <- runing log\n"
#    showWarn "  The above 3 files are processing logs. you can remove them safety.\n" 
##
#    showHi "
#    \r  $_indexFile <- pic&vid database\n" 
#    showWarn "  The .INDEX file is very important.\n" 
#    showErr "  DO NOT remove it!!\n\n" 
#    
##
##   showCursor
#============================================================================

#check the functional of \033[N`x', which `x' will change from a~z & A~Z
function _show()
{
#   $1 dir
#   $2 line
#   $3 col

    local _j;
    local _c;
    local _line=$2
    local _col=$3
    local _curDir=$1
    local _newDir='';
    local -a _dirs=('^' '>' 'v' '<');

    while read -n1 _c; do
        showHi "$_c\n" >>.log
        case $_c in
            0|4|8|c) _newDir=0 ;;
            1|5|9|d) _newDir=1 ;;
            2|6|a|e) _newDir=2 ;;
            3|7|b|f) _newDir=3 ;;
            *) continue ;; #_newDir=0 ;;
        esac

        for(( _j=0; ; _j++)){
        [[ ($_newDir == 0 && $_curDir == 2) ||
           ($_newDir == 2 && $_curDir == 0) ||
           ($_newDir == 1 && $_curDir == 3) ||
           ($_newDir == 3 && $_curDir == 1) ||
           ($_newDir == 0 && $_line == 1) ||
           ($_newDir == 1 && $_col == $_width) ||
           ($_newDir == 2 && $_line == $_height) ||
           ($_newDir == 3 && $_col == 1) ]] && _newDir=$(( (_newDir+1)%4 )) || break
           [[ $_j -gt 2 ]] && showErr "\rDesign Error!\n" >&2 && exit 9
        }

        case $_newDir in
            0) (( _line -- )) ;;
            1) (( _col ++ )) ;;
            2) (( _line ++ )) ;;
            3) (( _col -- )) ;;
            *) showErr "\rDesign Error!\n" >&2 && exit 9
        esac

        cursorTo $_line $_col >/dev/tty
        showMsg $_c >/dev/tty
        showMsg "($_line,$_col)${_dirs[$_curDir]},${_dirs[$_newDir]},$_c\n" >> .log
        _curDir=$_newDir
    done

    echo ";$_curDir;$_line;$_col"
}


_width=1
_height=1
_str=''
_continue="0 22 84"

_clrScr

#1. get screen width & height
_str=$( stty -a | sed -n '/rows.*columns/{s/.*\(rows.*columns[^;]*\);.*/\1/;p}' )
_width=${_str##* }
_height=${_str#* };_height=${_height%%;*}

#2. display the content
for(( i=0; ; i++ )){
    _str=$(echo $i | sha1sum | sed 's/ .*//')
    _continue=$(echo $_str | _show $_continue)
    _continue=${_continue//;/ }
#echo $_continue
}

#============================================================================
